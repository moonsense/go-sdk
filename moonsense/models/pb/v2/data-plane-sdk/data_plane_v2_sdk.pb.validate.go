// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: data_plane_v2_sdk.proto

package v2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LatitudeLongitude with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LatitudeLongitude) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LatitudeLongitude with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LatitudeLongitudeMultiError, or nil if none found.
func (m *LatitudeLongitude) ValidateAll() error {
	return m.validate(true)
}

func (m *LatitudeLongitude) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Latitude

	// no validation rules for Longitude

	if len(errors) > 0 {
		return LatitudeLongitudeMultiError(errors)
	}

	return nil
}

// LatitudeLongitudeMultiError is an error wrapping multiple validation errors
// returned by LatitudeLongitude.ValidateAll() if the designated constraints
// aren't met.
type LatitudeLongitudeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LatitudeLongitudeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LatitudeLongitudeMultiError) AllErrors() []error { return m }

// LatitudeLongitudeValidationError is the validation error returned by
// LatitudeLongitude.Validate if the designated constraints aren't met.
type LatitudeLongitudeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LatitudeLongitudeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LatitudeLongitudeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LatitudeLongitudeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LatitudeLongitudeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LatitudeLongitudeValidationError) ErrorName() string {
	return "LatitudeLongitudeValidationError"
}

// Error satisfies the builtin error interface
func (e LatitudeLongitudeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLatitudeLongitude.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LatitudeLongitudeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LatitudeLongitudeValidationError{}

// Validate checks the field values on BoundingCircle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BoundingCircle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoundingCircle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BoundingCircleMultiError,
// or nil if none found.
func (m *BoundingCircle) ValidateAll() error {
	return m.validate(true)
}

func (m *BoundingCircle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCentroid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BoundingCircleValidationError{
					field:  "Centroid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BoundingCircleValidationError{
					field:  "Centroid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCentroid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BoundingCircleValidationError{
				field:  "Centroid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Radius

	if len(errors) > 0 {
		return BoundingCircleMultiError(errors)
	}

	return nil
}

// BoundingCircleMultiError is an error wrapping multiple validation errors
// returned by BoundingCircle.ValidateAll() if the designated constraints
// aren't met.
type BoundingCircleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoundingCircleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoundingCircleMultiError) AllErrors() []error { return m }

// BoundingCircleValidationError is the validation error returned by
// BoundingCircle.Validate if the designated constraints aren't met.
type BoundingCircleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoundingCircleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoundingCircleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoundingCircleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoundingCircleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoundingCircleValidationError) ErrorName() string { return "BoundingCircleValidationError" }

// Error satisfies the builtin error interface
func (e BoundingCircleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoundingCircle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoundingCircleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoundingCircleValidationError{}

// Validate checks the field values on RecordingProfile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RecordingProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordingProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecordingProfileMultiError, or nil if none found.
func (m *RecordingProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordingProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	if len(errors) > 0 {
		return RecordingProfileMultiError(errors)
	}

	return nil
}

// RecordingProfileMultiError is an error wrapping multiple validation errors
// returned by RecordingProfile.ValidateAll() if the designated constraints
// aren't met.
type RecordingProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordingProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordingProfileMultiError) AllErrors() []error { return m }

// RecordingProfileValidationError is the validation error returned by
// RecordingProfile.Validate if the designated constraints aren't met.
type RecordingProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordingProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordingProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordingProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordingProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordingProfileValidationError) ErrorName() string { return "RecordingProfileValidationError" }

// Error satisfies the builtin error interface
func (e RecordingProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordingProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordingProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordingProfileValidationError{}

// Validate checks the field values on SessionMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SessionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionMetadataMultiError, or nil if none found.
func (m *SessionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstallId

	if _, ok := SessionMetadata_Platform_name[int32(m.GetPlatform())]; !ok {
		err := SessionMetadataValidationError{
			field:  "Platform",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manufacturer

	// no validation rules for Model

	// no validation rules for SystemVersion

	// no validation rules for IsDevicePhysical

	if all {
		switch v := interface{}(m.GetRecordingProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionMetadataValidationError{
					field:  "RecordingProfile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionMetadataValidationError{
					field:  "RecordingProfile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecordingProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionMetadataValidationError{
				field:  "RecordingProfile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DevicePhysicalWidth

	// no validation rules for DevicePhysicalHeight

	// no validation rules for DeviceLogicalWidth

	// no validation rules for DeviceLogicalHeight

	// no validation rules for DevicePixelRatio

	// no validation rules for ReleaseVersion

	if len(errors) > 0 {
		return SessionMetadataMultiError(errors)
	}

	return nil
}

// SessionMetadataMultiError is an error wrapping multiple validation errors
// returned by SessionMetadata.ValidateAll() if the designated constraints
// aren't met.
type SessionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionMetadataMultiError) AllErrors() []error { return m }

// SessionMetadataValidationError is the validation error returned by
// SessionMetadata.Validate if the designated constraints aren't met.
type SessionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionMetadataValidationError) ErrorName() string { return "SessionMetadataValidationError" }

// Error satisfies the builtin error interface
func (e SessionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionMetadataValidationError{}

// Validate checks the field values on SessionConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SessionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SessionConfigMultiError, or
// nil if none found.
func (m *SessionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestedDurationMillis

	// no validation rules for MaskText

	// no validation rules for SensorSamplingRate

	// no validation rules for BundleGenerationIntervalMillis

	if len(errors) > 0 {
		return SessionConfigMultiError(errors)
	}

	return nil
}

// SessionConfigMultiError is an error wrapping multiple validation errors
// returned by SessionConfig.ValidateAll() if the designated constraints
// aren't met.
type SessionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionConfigMultiError) AllErrors() []error { return m }

// SessionConfigValidationError is the validation error returned by
// SessionConfig.Validate if the designated constraints aren't met.
type SessionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionConfigValidationError) ErrorName() string { return "SessionConfigValidationError" }

// Error satisfies the builtin error interface
func (e SessionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionConfigValidationError{}

// Validate checks the field values on SessionLabel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SessionLabel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionLabel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SessionLabelMultiError, or
// nil if none found.
func (m *SessionLabel) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionLabel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabelId

	// no validation rules for SessionLabelId

	if len(m.GetName()) < 1 {
		err := SessionLabelValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionLabelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionLabelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionLabelValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SessionLabelMultiError(errors)
	}

	return nil
}

// SessionLabelMultiError is an error wrapping multiple validation errors
// returned by SessionLabel.ValidateAll() if the designated constraints aren't met.
type SessionLabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionLabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionLabelMultiError) AllErrors() []error { return m }

// SessionLabelValidationError is the validation error returned by
// SessionLabel.Validate if the designated constraints aren't met.
type SessionLabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionLabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionLabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionLabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionLabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionLabelValidationError) ErrorName() string { return "SessionLabelValidationError" }

// Error satisfies the builtin error interface
func (e SessionLabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionLabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionLabelValidationError{}

// Validate checks the field values on BucketedCounter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BucketedCounter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketedCounter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketedCounterMultiError, or nil if none found.
func (m *BucketedCounter) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketedCounter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuckets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BucketedCounterValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BucketedCounterValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BucketedCounterValidationError{
					field:  fmt.Sprintf("Buckets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return BucketedCounterMultiError(errors)
	}

	return nil
}

// BucketedCounterMultiError is an error wrapping multiple validation errors
// returned by BucketedCounter.ValidateAll() if the designated constraints
// aren't met.
type BucketedCounterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketedCounterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketedCounterMultiError) AllErrors() []error { return m }

// BucketedCounterValidationError is the validation error returned by
// BucketedCounter.Validate if the designated constraints aren't met.
type BucketedCounterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketedCounterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketedCounterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketedCounterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketedCounterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketedCounterValidationError) ErrorName() string { return "BucketedCounterValidationError" }

// Error satisfies the builtin error interface
func (e BucketedCounterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketedCounter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketedCounterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketedCounterValidationError{}

// Validate checks the field values on CDF with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *CDF) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CDF with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CDFMultiError, or nil if none found.
func (m *CDF) ValidateAll() error {
	return m.validate(true)
}

func (m *CDF) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CDFMultiError(errors)
	}

	return nil
}

// CDFMultiError is an error wrapping multiple validation errors returned by
// CDF.ValidateAll() if the designated constraints aren't met.
type CDFMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CDFMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CDFMultiError) AllErrors() []error { return m }

// CDFValidationError is the validation error returned by CDF.Validate if the
// designated constraints aren't met.
type CDFValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CDFValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CDFValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CDFValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CDFValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CDFValidationError) ErrorName() string { return "CDFValidationError" }

// Error satisfies the builtin error interface
func (e CDFValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCDF.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CDFValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CDFValidationError{}

// Validate checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Session) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SessionMultiError, or nil if none found.
func (m *Session) ValidateAll() error {
	return m.validate(true)
}

func (m *Session) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for AppId

	if all {
		switch v := interface{}(m.GetOldestEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "OldestEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "OldestEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldestEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "OldestEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewestEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "NewestEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "NewestEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewestEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "NewestEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCircle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Circle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Circle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCircle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "Circle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetCounters()))
		i := 0
		for key := range m.GetCounters() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCounters()[key]
			_ = val

			// no validation rules for Counters[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SessionValidationError{
							field:  fmt.Sprintf("Counters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SessionValidationError{
							field:  fmt.Sprintf("Counters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SessionValidationError{
						field:  fmt.Sprintf("Counters[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetCdfs()))
		i := 0
		for key := range m.GetCdfs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCdfs()[key]
			_ = val

			// no validation rules for Cdfs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SessionValidationError{
							field:  fmt.Sprintf("Cdfs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SessionValidationError{
							field:  fmt.Sprintf("Cdfs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SessionValidationError{
						field:  fmt.Sprintf("Cdfs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for RegionId

	// no validation rules for ClientSessionGroupId

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for JourneyId

	if len(errors) > 0 {
		return SessionMultiError(errors)
	}

	return nil
}

// SessionMultiError is an error wrapping multiple validation errors returned
// by Session.ValidateAll() if the designated constraints aren't met.
type SessionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionMultiError) AllErrors() []error { return m }

// SessionValidationError is the validation error returned by Session.Validate
// if the designated constraints aren't met.
type SessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionValidationError) ErrorName() string { return "SessionValidationError" }

// Error satisfies the builtin error interface
func (e SessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionValidationError{}

// Validate checks the field values on SessionLabelCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionLabelCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionLabelCreateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionLabelCreateRequestMultiError, or nil if none found.
func (m *SessionLabelCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionLabelCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionLabelCreateRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionLabelCreateRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionLabelCreateRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SessionLabelCreateRequestMultiError(errors)
	}

	return nil
}

// SessionLabelCreateRequestMultiError is an error wrapping multiple validation
// errors returned by SessionLabelCreateRequest.ValidateAll() if the
// designated constraints aren't met.
type SessionLabelCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionLabelCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionLabelCreateRequestMultiError) AllErrors() []error { return m }

// SessionLabelCreateRequestValidationError is the validation error returned by
// SessionLabelCreateRequest.Validate if the designated constraints aren't met.
type SessionLabelCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionLabelCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionLabelCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionLabelCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionLabelCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionLabelCreateRequestValidationError) ErrorName() string {
	return "SessionLabelCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SessionLabelCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionLabelCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionLabelCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionLabelCreateRequestValidationError{}

// Validate checks the field values on SessionLabelCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionLabelCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionLabelCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionLabelCreateResponseMultiError, or nil if none found.
func (m *SessionLabelCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionLabelCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SessionLabelCreateResponseMultiError(errors)
	}

	return nil
}

// SessionLabelCreateResponseMultiError is an error wrapping multiple
// validation errors returned by SessionLabelCreateResponse.ValidateAll() if
// the designated constraints aren't met.
type SessionLabelCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionLabelCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionLabelCreateResponseMultiError) AllErrors() []error { return m }

// SessionLabelCreateResponseValidationError is the validation error returned
// by SessionLabelCreateResponse.Validate if the designated constraints aren't met.
type SessionLabelCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionLabelCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionLabelCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionLabelCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionLabelCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionLabelCreateResponseValidationError) ErrorName() string {
	return "SessionLabelCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SessionLabelCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionLabelCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionLabelCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionLabelCreateResponseValidationError{}

// Validate checks the field values on NetworkPacketCaptureClientResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *NetworkPacketCaptureClientResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkPacketCaptureClientResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// NetworkPacketCaptureClientResponseMultiError, or nil if none found.
func (m *NetworkPacketCaptureClientResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkPacketCaptureClientResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	if len(errors) > 0 {
		return NetworkPacketCaptureClientResponseMultiError(errors)
	}

	return nil
}

// NetworkPacketCaptureClientResponseMultiError is an error wrapping multiple
// validation errors returned by
// NetworkPacketCaptureClientResponse.ValidateAll() if the designated
// constraints aren't met.
type NetworkPacketCaptureClientResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkPacketCaptureClientResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkPacketCaptureClientResponseMultiError) AllErrors() []error { return m }

// NetworkPacketCaptureClientResponseValidationError is the validation error
// returned by NetworkPacketCaptureClientResponse.Validate if the designated
// constraints aren't met.
type NetworkPacketCaptureClientResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkPacketCaptureClientResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkPacketCaptureClientResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkPacketCaptureClientResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkPacketCaptureClientResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkPacketCaptureClientResponseValidationError) ErrorName() string {
	return "NetworkPacketCaptureClientResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NetworkPacketCaptureClientResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkPacketCaptureClientResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkPacketCaptureClientResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkPacketCaptureClientResponseValidationError{}

// Validate checks the field values on BundleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BundleCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BundleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BundleCreateRequestMultiError, or nil if none found.
func (m *BundleCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BundleCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	for idx, item := range m.GetBundles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleCreateRequestValidationError{
						field:  fmt.Sprintf("Bundles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleCreateRequestValidationError{
						field:  fmt.Sprintf("Bundles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleCreateRequestValidationError{
					field:  fmt.Sprintf("Bundles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for InstallId

	// no validation rules for ClientUserId

	if len(errors) > 0 {
		return BundleCreateRequestMultiError(errors)
	}

	return nil
}

// BundleCreateRequestMultiError is an error wrapping multiple validation
// errors returned by BundleCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type BundleCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BundleCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BundleCreateRequestMultiError) AllErrors() []error { return m }

// BundleCreateRequestValidationError is the validation error returned by
// BundleCreateRequest.Validate if the designated constraints aren't met.
type BundleCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BundleCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BundleCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BundleCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BundleCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BundleCreateRequestValidationError) ErrorName() string {
	return "BundleCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BundleCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBundleCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BundleCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BundleCreateRequestValidationError{}

// Validate checks the field values on BundleCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BundleCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BundleCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BundleCreateResponseMultiError, or nil if none found.
func (m *BundleCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BundleCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCount

	// no validation rules for SuccessCount

	if len(errors) > 0 {
		return BundleCreateResponseMultiError(errors)
	}

	return nil
}

// BundleCreateResponseMultiError is an error wrapping multiple validation
// errors returned by BundleCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type BundleCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BundleCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BundleCreateResponseMultiError) AllErrors() []error { return m }

// BundleCreateResponseValidationError is the validation error returned by
// BundleCreateResponse.Validate if the designated constraints aren't met.
type BundleCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BundleCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BundleCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BundleCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BundleCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BundleCreateResponseValidationError) ErrorName() string {
	return "BundleCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BundleCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBundleCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BundleCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BundleCreateResponseValidationError{}

// Validate checks the field values on BucketedCounter_Bucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BucketedCounter_Bucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketedCounter_Bucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketedCounter_BucketMultiError, or nil if none found.
func (m *BucketedCounter_Bucket) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketedCounter_Bucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartTime

	// no validation rules for Value

	if len(errors) > 0 {
		return BucketedCounter_BucketMultiError(errors)
	}

	return nil
}

// BucketedCounter_BucketMultiError is an error wrapping multiple validation
// errors returned by BucketedCounter_Bucket.ValidateAll() if the designated
// constraints aren't met.
type BucketedCounter_BucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketedCounter_BucketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketedCounter_BucketMultiError) AllErrors() []error { return m }

// BucketedCounter_BucketValidationError is the validation error returned by
// BucketedCounter_Bucket.Validate if the designated constraints aren't met.
type BucketedCounter_BucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketedCounter_BucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketedCounter_BucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketedCounter_BucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketedCounter_BucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketedCounter_BucketValidationError) ErrorName() string {
	return "BucketedCounter_BucketValidationError"
}

// Error satisfies the builtin error interface
func (e BucketedCounter_BucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketedCounter_Bucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketedCounter_BucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketedCounter_BucketValidationError{}
