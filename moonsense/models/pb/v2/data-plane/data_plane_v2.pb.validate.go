// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: data_plane_v2.proto

package v2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LabelWithStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabelWithStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelWithStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabelWithStatsMultiError,
// or nil if none found.
func (m *LabelWithStats) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelWithStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for SessionsCount

	if len(errors) > 0 {
		return LabelWithStatsMultiError(errors)
	}

	return nil
}

// LabelWithStatsMultiError is an error wrapping multiple validation errors
// returned by LabelWithStats.ValidateAll() if the designated constraints
// aren't met.
type LabelWithStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelWithStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelWithStatsMultiError) AllErrors() []error { return m }

// LabelWithStatsValidationError is the validation error returned by
// LabelWithStats.Validate if the designated constraints aren't met.
type LabelWithStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelWithStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelWithStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelWithStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelWithStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelWithStatsValidationError) ErrorName() string { return "LabelWithStatsValidationError" }

// Error satisfies the builtin error interface
func (e LabelWithStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelWithStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelWithStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelWithStatsValidationError{}

// Validate checks the field values on App with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *App) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on App with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AppMultiError, or nil if none found.
func (m *App) ValidateAll() error {
	return m.validate(true)
}

func (m *App) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for ProjectId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppMultiError(errors)
	}

	return nil
}

// AppMultiError is an error wrapping multiple validation errors returned by
// App.ValidateAll() if the designated constraints aren't met.
type AppMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppMultiError) AllErrors() []error { return m }

// AppValidationError is the validation error returned by App.Validate if the
// designated constraints aren't met.
type AppValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppValidationError) ErrorName() string { return "AppValidationError" }

// Error satisfies the builtin error interface
func (e AppValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppValidationError{}

// Validate checks the field values on AppStats with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppStats with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AppStatsMultiError, or nil
// if none found.
func (m *AppStats) ValidateAll() error {
	return m.validate(true)
}

func (m *AppStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for RecordingProfileStats

	if len(errors) > 0 {
		return AppStatsMultiError(errors)
	}

	return nil
}

// AppStatsMultiError is an error wrapping multiple validation errors returned
// by AppStats.ValidateAll() if the designated constraints aren't met.
type AppStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppStatsMultiError) AllErrors() []error { return m }

// AppStatsValidationError is the validation error returned by
// AppStats.Validate if the designated constraints aren't met.
type AppStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppStatsValidationError) ErrorName() string { return "AppStatsValidationError" }

// Error satisfies the builtin error interface
func (e AppStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppStatsValidationError{}

// Validate checks the field values on Chunk with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Chunk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Chunk with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChunkMultiError, or nil if none found.
func (m *Chunk) ValidateAll() error {
	return m.validate(true)
}

func (m *Chunk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChunkId

	// no validation rules for Md5

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChunkValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChunkValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChunkValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChunkMultiError(errors)
	}

	return nil
}

// ChunkMultiError is an error wrapping multiple validation errors returned by
// Chunk.ValidateAll() if the designated constraints aren't met.
type ChunkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChunkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChunkMultiError) AllErrors() []error { return m }

// ChunkValidationError is the validation error returned by Chunk.Validate if
// the designated constraints aren't met.
type ChunkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChunkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChunkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChunkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChunkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChunkValidationError) ErrorName() string { return "ChunkValidationError" }

// Error satisfies the builtin error interface
func (e ChunkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChunk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChunkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChunkValidationError{}

// Validate checks the field values on Card with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Card) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Card with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CardMultiError, or nil if none found.
func (m *Card) ValidateAll() error {
	return m.validate(true)
}

func (m *Card) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for CardId

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for SourceType

	// no validation rules for SourceId

	// no validation rules for Payload

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CardMultiError(errors)
	}

	return nil
}

// CardMultiError is an error wrapping multiple validation errors returned by
// Card.ValidateAll() if the designated constraints aren't met.
type CardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardMultiError) AllErrors() []error { return m }

// CardValidationError is the validation error returned by Card.Validate if the
// designated constraints aren't met.
type CardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardValidationError) ErrorName() string { return "CardValidationError" }

// Error satisfies the builtin error interface
func (e CardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardValidationError{}

// Validate checks the field values on WebhookPayload with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebhookPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebhookPayload with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebhookPayloadMultiError,
// or nil if none found.
func (m *WebhookPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *WebhookPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	if len(m.GetAppId()) < 1 {
		err := WebhookPayloadValidationError{
			field:  "AppId",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSessionId()) < 1 {
		err := WebhookPayloadValidationError{
			field:  "SessionId",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := WebhookEventTypes_name[int32(m.GetEventType())]; !ok {
		err := WebhookPayloadValidationError{
			field:  "EventType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBundle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookPayloadValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookPayloadValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBundle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookPayloadValidationError{
				field:  "Bundle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClientSessionGroupId

	// no validation rules for JourneyId

	if len(errors) > 0 {
		return WebhookPayloadMultiError(errors)
	}

	return nil
}

// WebhookPayloadMultiError is an error wrapping multiple validation errors
// returned by WebhookPayload.ValidateAll() if the designated constraints
// aren't met.
type WebhookPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookPayloadMultiError) AllErrors() []error { return m }

// WebhookPayloadValidationError is the validation error returned by
// WebhookPayload.Validate if the designated constraints aren't met.
type WebhookPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookPayloadValidationError) ErrorName() string { return "WebhookPayloadValidationError" }

// Error satisfies the builtin error interface
func (e WebhookPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhookPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookPayloadValidationError{}

// Validate checks the field values on SessionListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionListResponseMultiError, or nil if none found.
func (m *SessionListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSessions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionListResponseValidationError{
						field:  fmt.Sprintf("Sessions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionListResponseValidationError{
						field:  fmt.Sprintf("Sessions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionListResponseValidationError{
					field:  fmt.Sprintf("Sessions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionListResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SessionListResponseMultiError(errors)
	}

	return nil
}

// SessionListResponseMultiError is an error wrapping multiple validation
// errors returned by SessionListResponse.ValidateAll() if the designated
// constraints aren't met.
type SessionListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionListResponseMultiError) AllErrors() []error { return m }

// SessionListResponseValidationError is the validation error returned by
// SessionListResponse.Validate if the designated constraints aren't met.
type SessionListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionListResponseValidationError) ErrorName() string {
	return "SessionListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SessionListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionListResponseValidationError{}

// Validate checks the field values on SessionDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionDeleteResponseMultiError, or nil if none found.
func (m *SessionDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	if len(errors) > 0 {
		return SessionDeleteResponseMultiError(errors)
	}

	return nil
}

// SessionDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by SessionDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type SessionDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionDeleteResponseMultiError) AllErrors() []error { return m }

// SessionDeleteResponseValidationError is the validation error returned by
// SessionDeleteResponse.Validate if the designated constraints aren't met.
type SessionDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionDeleteResponseValidationError) ErrorName() string {
	return "SessionDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SessionDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionDeleteResponseValidationError{}

// Validate checks the field values on ChunksListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChunksListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChunksListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChunksListResponseMultiError, or nil if none found.
func (m *ChunksListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChunksListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	for idx, item := range m.GetChunks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChunksListResponseValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChunksListResponseValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChunksListResponseValidationError{
					field:  fmt.Sprintf("Chunks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChunksListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChunksListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChunksListResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChunksListResponseMultiError(errors)
	}

	return nil
}

// ChunksListResponseMultiError is an error wrapping multiple validation errors
// returned by ChunksListResponse.ValidateAll() if the designated constraints
// aren't met.
type ChunksListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChunksListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChunksListResponseMultiError) AllErrors() []error { return m }

// ChunksListResponseValidationError is the validation error returned by
// ChunksListResponse.Validate if the designated constraints aren't met.
type ChunksListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChunksListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChunksListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChunksListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChunksListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChunksListResponseValidationError) ErrorName() string {
	return "ChunksListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChunksListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChunksListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChunksListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChunksListResponseValidationError{}

// Validate checks the field values on CardListResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CardListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardListResponseMultiError, or nil if none found.
func (m *CardListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CardListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	for idx, item := range m.GetCards() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardListResponseValidationError{
						field:  fmt.Sprintf("Cards[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardListResponseValidationError{
						field:  fmt.Sprintf("Cards[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardListResponseValidationError{
					field:  fmt.Sprintf("Cards[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardListResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardListResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CardListResponseMultiError(errors)
	}

	return nil
}

// CardListResponseMultiError is an error wrapping multiple validation errors
// returned by CardListResponse.ValidateAll() if the designated constraints
// aren't met.
type CardListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardListResponseMultiError) AllErrors() []error { return m }

// CardListResponseValidationError is the validation error returned by
// CardListResponse.Validate if the designated constraints aren't met.
type CardListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardListResponseValidationError) ErrorName() string { return "CardListResponseValidationError" }

// Error satisfies the builtin error interface
func (e CardListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardListResponseValidationError{}

// Validate checks the field values on CardDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CardDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardDeleteResponseMultiError, or nil if none found.
func (m *CardDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CardDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CardId

	if len(errors) > 0 {
		return CardDeleteResponseMultiError(errors)
	}

	return nil
}

// CardDeleteResponseMultiError is an error wrapping multiple validation errors
// returned by CardDeleteResponse.ValidateAll() if the designated constraints
// aren't met.
type CardDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardDeleteResponseMultiError) AllErrors() []error { return m }

// CardDeleteResponseValidationError is the validation error returned by
// CardDeleteResponse.Validate if the designated constraints aren't met.
type CardDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardDeleteResponseValidationError) ErrorName() string {
	return "CardDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CardDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardDeleteResponseValidationError{}

// Validate checks the field values on LabelListResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LabelListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LabelListResponseMultiError, or nil if none found.
func (m *LabelListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LabelListResponseValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LabelListResponseValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LabelListResponseValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LabelListResponseMultiError(errors)
	}

	return nil
}

// LabelListResponseMultiError is an error wrapping multiple validation errors
// returned by LabelListResponse.ValidateAll() if the designated constraints
// aren't met.
type LabelListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelListResponseMultiError) AllErrors() []error { return m }

// LabelListResponseValidationError is the validation error returned by
// LabelListResponse.Validate if the designated constraints aren't met.
type LabelListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelListResponseValidationError) ErrorName() string {
	return "LabelListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LabelListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelListResponseValidationError{}

// Validate checks the field values on LabelsTopResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LabelsTopResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelsTopResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LabelsTopResponseMultiError, or nil if none found.
func (m *LabelsTopResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelsTopResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LabelsTopResponseValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LabelsTopResponseValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LabelsTopResponseValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LabelsTopResponseMultiError(errors)
	}

	return nil
}

// LabelsTopResponseMultiError is an error wrapping multiple validation errors
// returned by LabelsTopResponse.ValidateAll() if the designated constraints
// aren't met.
type LabelsTopResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelsTopResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelsTopResponseMultiError) AllErrors() []error { return m }

// LabelsTopResponseValidationError is the validation error returned by
// LabelsTopResponse.Validate if the designated constraints aren't met.
type LabelsTopResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelsTopResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelsTopResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelsTopResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelsTopResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelsTopResponseValidationError) ErrorName() string {
	return "LabelsTopResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LabelsTopResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelsTopResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelsTopResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelsTopResponseValidationError{}

// Validate checks the field values on PaginatedFieldsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaginatedFieldsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaginatedFieldsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaginatedFieldsResponseMultiError, or nil if none found.
func (m *PaginatedFieldsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaginatedFieldsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBundle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaginatedFieldsResponseValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaginatedFieldsResponseValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBundle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaginatedFieldsResponseValidationError{
				field:  "Bundle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxDeterminedAt

	// no validation rules for FromBundleCursor

	if len(errors) > 0 {
		return PaginatedFieldsResponseMultiError(errors)
	}

	return nil
}

// PaginatedFieldsResponseMultiError is an error wrapping multiple validation
// errors returned by PaginatedFieldsResponse.ValidateAll() if the designated
// constraints aren't met.
type PaginatedFieldsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginatedFieldsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaginatedFieldsResponseMultiError) AllErrors() []error { return m }

// PaginatedFieldsResponseValidationError is the validation error returned by
// PaginatedFieldsResponse.Validate if the designated constraints aren't met.
type PaginatedFieldsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaginatedFieldsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaginatedFieldsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaginatedFieldsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaginatedFieldsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaginatedFieldsResponseValidationError) ErrorName() string {
	return "PaginatedFieldsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaginatedFieldsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaginatedFieldsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaginatedFieldsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaginatedFieldsResponseValidationError{}

// Validate checks the field values on FeatureEnvelope with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FeatureEnvelope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeatureEnvelope with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeatureEnvelopeMultiError, or nil if none found.
func (m *FeatureEnvelope) ValidateAll() error {
	return m.validate(true)
}

func (m *FeatureEnvelope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFeature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FeatureEnvelopeValidationError{
					field:  "Feature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FeatureEnvelopeValidationError{
					field:  "Feature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFeature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FeatureEnvelopeValidationError{
				field:  "Feature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Key

	if len(errors) > 0 {
		return FeatureEnvelopeMultiError(errors)
	}

	return nil
}

// FeatureEnvelopeMultiError is an error wrapping multiple validation errors
// returned by FeatureEnvelope.ValidateAll() if the designated constraints
// aren't met.
type FeatureEnvelopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeatureEnvelopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeatureEnvelopeMultiError) AllErrors() []error { return m }

// FeatureEnvelopeValidationError is the validation error returned by
// FeatureEnvelope.Validate if the designated constraints aren't met.
type FeatureEnvelopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeatureEnvelopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeatureEnvelopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeatureEnvelopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeatureEnvelopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeatureEnvelopeValidationError) ErrorName() string { return "FeatureEnvelopeValidationError" }

// Error satisfies the builtin error interface
func (e FeatureEnvelopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeatureEnvelope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeatureEnvelopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeatureEnvelopeValidationError{}

// Validate checks the field values on FeatureEnvelopeList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FeatureEnvelopeList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeatureEnvelopeList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeatureEnvelopeListMultiError, or nil if none found.
func (m *FeatureEnvelopeList) ValidateAll() error {
	return m.validate(true)
}

func (m *FeatureEnvelopeList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFeatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FeatureEnvelopeListValidationError{
						field:  fmt.Sprintf("Features[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FeatureEnvelopeListValidationError{
						field:  fmt.Sprintf("Features[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FeatureEnvelopeListValidationError{
					field:  fmt.Sprintf("Features[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FeatureEnvelopeListMultiError(errors)
	}

	return nil
}

// FeatureEnvelopeListMultiError is an error wrapping multiple validation
// errors returned by FeatureEnvelopeList.ValidateAll() if the designated
// constraints aren't met.
type FeatureEnvelopeListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeatureEnvelopeListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeatureEnvelopeListMultiError) AllErrors() []error { return m }

// FeatureEnvelopeListValidationError is the validation error returned by
// FeatureEnvelopeList.Validate if the designated constraints aren't met.
type FeatureEnvelopeListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeatureEnvelopeListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeatureEnvelopeListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeatureEnvelopeListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeatureEnvelopeListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeatureEnvelopeListValidationError) ErrorName() string {
	return "FeatureEnvelopeListValidationError"
}

// Error satisfies the builtin error interface
func (e FeatureEnvelopeListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeatureEnvelopeList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeatureEnvelopeListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeatureEnvelopeListValidationError{}

// Validate checks the field values on FeatureListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FeatureListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeatureListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeatureListResponseMultiError, or nil if none found.
func (m *FeatureListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FeatureListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	{
		sorted_keys := make([]string, len(m.GetFeatures()))
		i := 0
		for key := range m.GetFeatures() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFeatures()[key]
			_ = val

			// no validation rules for Features[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FeatureListResponseValidationError{
							field:  fmt.Sprintf("Features[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FeatureListResponseValidationError{
							field:  fmt.Sprintf("Features[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FeatureListResponseValidationError{
						field:  fmt.Sprintf("Features[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return FeatureListResponseMultiError(errors)
	}

	return nil
}

// FeatureListResponseMultiError is an error wrapping multiple validation
// errors returned by FeatureListResponse.ValidateAll() if the designated
// constraints aren't met.
type FeatureListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeatureListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeatureListResponseMultiError) AllErrors() []error { return m }

// FeatureListResponseValidationError is the validation error returned by
// FeatureListResponse.Validate if the designated constraints aren't met.
type FeatureListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeatureListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeatureListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeatureListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeatureListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeatureListResponseValidationError) ErrorName() string {
	return "FeatureListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FeatureListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeatureListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeatureListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeatureListResponseValidationError{}

// Validate checks the field values on SignalsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalsResponseMultiError, or nil if none found.
func (m *SignalsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalsResponseValidationError{
					field:  "Os",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalsResponseValidationError{
					field:  "Os",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalsResponseValidationError{
				field:  "Os",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalsResponseMultiError(errors)
	}

	return nil
}

// SignalsResponseMultiError is an error wrapping multiple validation errors
// returned by SignalsResponse.ValidateAll() if the designated constraints
// aren't met.
type SignalsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalsResponseMultiError) AllErrors() []error { return m }

// SignalsResponseValidationError is the validation error returned by
// SignalsResponse.Validate if the designated constraints aren't met.
type SignalsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalsResponseValidationError) ErrorName() string { return "SignalsResponseValidationError" }

// Error satisfies the builtin error interface
func (e SignalsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalsResponseValidationError{}
