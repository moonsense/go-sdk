// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bundle_v2.proto

package bundle

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	v2 "github.com/moonsense/go-sdk/moonsense/models/pb/v2/common"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = v2.SensorType(0)
)

// Validate checks the field values on SealedBundle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SealedBundle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SealedBundle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SealedBundleMultiError, or
// nil if none found.
func (m *SealedBundle) ValidateAll() error {
	return m.validate(true)
}

func (m *SealedBundle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBundle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SealedBundleValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SealedBundleValidationError{
					field:  "Bundle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBundle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SealedBundleValidationError{
				field:  "Bundle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AppId

	// no validation rules for CredentialId

	// no validation rules for SessionId

	// no validation rules for UserId

	// no validation rules for ServerTimeMillis

	// no validation rules for InstallId

	// no validation rules for ClientUserId

	// no validation rules for RemoteIp

	// no validation rules for JourneyId

	if len(errors) > 0 {
		return SealedBundleMultiError(errors)
	}

	return nil
}

// SealedBundleMultiError is an error wrapping multiple validation errors
// returned by SealedBundle.ValidateAll() if the designated constraints aren't met.
type SealedBundleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SealedBundleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SealedBundleMultiError) AllErrors() []error { return m }

// SealedBundleValidationError is the validation error returned by
// SealedBundle.Validate if the designated constraints aren't met.
type SealedBundleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SealedBundleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SealedBundleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SealedBundleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SealedBundleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SealedBundleValidationError) ErrorName() string { return "SealedBundleValidationError" }

// Error satisfies the builtin error interface
func (e SealedBundleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSealedBundle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SealedBundleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SealedBundleValidationError{}

// Validate checks the field values on Bundle with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bundle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bundle with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BundleMultiError, or nil if none found.
func (m *Bundle) ValidateAll() error {
	return m.validate(true)
}

func (m *Bundle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLocationData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("LocationData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("LocationData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("LocationData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAccelerometerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("AccelerometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("AccelerometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("AccelerometerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMagnetometerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("MagnetometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("MagnetometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("MagnetometerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetGyroscopeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("GyroscopeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("GyroscopeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("GyroscopeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetClientTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "ClientTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "ClientTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BundleValidationError{
				field:  "ClientTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBattery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "Battery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "Battery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBattery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BundleValidationError{
				field:  "Battery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOrientationData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("OrientationData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("OrientationData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("OrientationData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPointerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("PointerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("PointerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("PointerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLinearAccelerometerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("LinearAccelerometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("LinearAccelerometerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("LinearAccelerometerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Index

	for idx, item := range m.GetTextChangeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("TextChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("TextChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("TextChangeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKeyPressData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("KeyPressData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("KeyPressData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("KeyPressData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFocusChangeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("FocusChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("FocusChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("FocusChangeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetViewportScrollData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ViewportScrollData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ViewportScrollData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("ViewportScrollData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMouseWheelData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("MouseWheelData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("MouseWheelData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("MouseWheelData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPermissionEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("PermissionEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("PermissionEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("PermissionEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetViewportSizeEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ViewportSizeEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ViewportSizeEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("ViewportSizeEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAppLifeCycleEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("AppLifeCycleEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("AppLifeCycleEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("AppLifeCycleEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("CustomEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("CustomEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("CustomEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetClickData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ClickData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ClickData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("ClickData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsFinalBundle

	{
		sorted_keys := make([]string, len(m.GetFeatures()))
		i := 0
		for key := range m.GetFeatures() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFeatures()[key]
			_ = val

			// no validation rules for Features[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BundleValidationError{
							field:  fmt.Sprintf("Features[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BundleValidationError{
							field:  fmt.Sprintf("Features[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BundleValidationError{
						field:  fmt.Sprintf("Features[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetInputChangeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("InputChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("InputChangeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("InputChangeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFormSubmitEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("FormSubmitEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("FormSubmitEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("FormSubmitEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContextMenuEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ContextMenuEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BundleValidationError{
						field:  fmt.Sprintf("ContextMenuEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BundleValidationError{
					field:  fmt.Sprintf("ContextMenuEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFrameRateEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "FrameRateEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BundleValidationError{
					field:  "FrameRateEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrameRateEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BundleValidationError{
				field:  "FrameRateEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BundleMultiError(errors)
	}

	return nil
}

// BundleMultiError is an error wrapping multiple validation errors returned by
// Bundle.ValidateAll() if the designated constraints aren't met.
type BundleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BundleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BundleMultiError) AllErrors() []error { return m }

// BundleValidationError is the validation error returned by Bundle.Validate if
// the designated constraints aren't met.
type BundleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BundleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BundleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BundleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BundleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BundleValidationError) ErrorName() string { return "BundleValidationError" }

// Error satisfies the builtin error interface
func (e BundleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBundle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BundleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BundleValidationError{}

// Validate checks the field values on Offset2D with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Offset2D) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Offset2D with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Offset2DMultiError, or nil
// if none found.
func (m *Offset2D) ValidateAll() error {
	return m.validate(true)
}

func (m *Offset2D) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dx

	// no validation rules for Dy

	if len(errors) > 0 {
		return Offset2DMultiError(errors)
	}

	return nil
}

// Offset2DMultiError is an error wrapping multiple validation errors returned
// by Offset2D.ValidateAll() if the designated constraints aren't met.
type Offset2DMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Offset2DMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Offset2DMultiError) AllErrors() []error { return m }

// Offset2DValidationError is the validation error returned by
// Offset2D.Validate if the designated constraints aren't met.
type Offset2DValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Offset2DValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Offset2DValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Offset2DValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Offset2DValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Offset2DValidationError) ErrorName() string { return "Offset2DValidationError" }

// Error satisfies the builtin error interface
func (e Offset2DValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOffset2D.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Offset2DValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Offset2DValidationError{}

// Validate checks the field values on ClosedRange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClosedRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClosedRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClosedRangeMultiError, or
// nil if none found.
func (m *ClosedRange) ValidateAll() error {
	return m.validate(true)
}

func (m *ClosedRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LowerBound

	// no validation rules for UpperBound

	if len(errors) > 0 {
		return ClosedRangeMultiError(errors)
	}

	return nil
}

// ClosedRangeMultiError is an error wrapping multiple validation errors
// returned by ClosedRange.ValidateAll() if the designated constraints aren't met.
type ClosedRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClosedRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClosedRangeMultiError) AllErrors() []error { return m }

// ClosedRangeValidationError is the validation error returned by
// ClosedRange.Validate if the designated constraints aren't met.
type ClosedRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClosedRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClosedRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClosedRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClosedRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClosedRangeValidationError) ErrorName() string { return "ClosedRangeValidationError" }

// Error satisfies the builtin error interface
func (e ClosedRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClosedRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClosedRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClosedRangeValidationError{}

// Validate checks the field values on Battery with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Battery) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Battery with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BatteryMultiError, or nil if none found.
func (m *Battery) ValidateAll() error {
	return m.validate(true)
}

func (m *Battery) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Capacity

	// no validation rules for State

	if len(errors) > 0 {
		return BatteryMultiError(errors)
	}

	return nil
}

// BatteryMultiError is an error wrapping multiple validation errors returned
// by Battery.ValidateAll() if the designated constraints aren't met.
type BatteryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatteryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatteryMultiError) AllErrors() []error { return m }

// BatteryValidationError is the validation error returned by Battery.Validate
// if the designated constraints aren't met.
type BatteryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatteryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatteryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatteryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatteryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatteryValidationError) ErrorName() string { return "BatteryValidationError" }

// Error satisfies the builtin error interface
func (e BatteryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBattery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatteryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatteryValidationError{}

// Validate checks the field values on Orientation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Orientation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Orientation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrientationMultiError, or
// nil if none found.
func (m *Orientation) ValidateAll() error {
	return m.validate(true)
}

func (m *Orientation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for Azimuth

	// no validation rules for Pitch

	// no validation rules for Roll

	if len(errors) > 0 {
		return OrientationMultiError(errors)
	}

	return nil
}

// OrientationMultiError is an error wrapping multiple validation errors
// returned by Orientation.ValidateAll() if the designated constraints aren't met.
type OrientationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrientationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrientationMultiError) AllErrors() []error { return m }

// OrientationValidationError is the validation error returned by
// Orientation.Validate if the designated constraints aren't met.
type OrientationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrientationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrientationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrientationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrientationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrientationValidationError) ErrorName() string { return "OrientationValidationError" }

// Error satisfies the builtin error interface
func (e OrientationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrientation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrientationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrientationValidationError{}

// Validate checks the field values on Clock with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Clock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Clock with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClockMultiError, or nil if none found.
func (m *Clock) ValidateAll() error {
	return m.validate(true)
}

func (m *Clock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WallTimeMillis

	// no validation rules for TimerMillis

	// no validation rules for TimerRealtimeMillis

	if len(errors) > 0 {
		return ClockMultiError(errors)
	}

	return nil
}

// ClockMultiError is an error wrapping multiple validation errors returned by
// Clock.ValidateAll() if the designated constraints aren't met.
type ClockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClockMultiError) AllErrors() []error { return m }

// ClockValidationError is the validation error returned by Clock.Validate if
// the designated constraints aren't met.
type ClockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClockValidationError) ErrorName() string { return "ClockValidationError" }

// Error satisfies the builtin error interface
func (e ClockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClockValidationError{}

// Validate checks the field values on Location with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Location with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocationMultiError, or nil
// if none found.
func (m *Location) ValidateAll() error {
	return m.validate(true)
}

func (m *Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for HorizontalAccuracy

	// no validation rules for VerticalAccurracy

	// no validation rules for Altitude

	// no validation rules for Bearing

	// no validation rules for BearingAccuracyDegrees

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Provider

	// no validation rules for Speed

	// no validation rules for SpeedAccurracy

	if len(errors) > 0 {
		return LocationMultiError(errors)
	}

	return nil
}

// LocationMultiError is an error wrapping multiple validation errors returned
// by Location.ValidateAll() if the designated constraints aren't met.
type LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationMultiError) AllErrors() []error { return m }

// LocationValidationError is the validation error returned by
// Location.Validate if the designated constraints aren't met.
type LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationValidationError) ErrorName() string { return "LocationValidationError" }

// Error satisfies the builtin error interface
func (e LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationValidationError{}

// Validate checks the field values on Accelerometer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Accelerometer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Accelerometer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccelerometerMultiError, or
// nil if none found.
func (m *Accelerometer) ValidateAll() error {
	return m.validate(true)
}

func (m *Accelerometer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for X

	// no validation rules for Y

	// no validation rules for Z

	if len(errors) > 0 {
		return AccelerometerMultiError(errors)
	}

	return nil
}

// AccelerometerMultiError is an error wrapping multiple validation errors
// returned by Accelerometer.ValidateAll() if the designated constraints
// aren't met.
type AccelerometerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccelerometerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccelerometerMultiError) AllErrors() []error { return m }

// AccelerometerValidationError is the validation error returned by
// Accelerometer.Validate if the designated constraints aren't met.
type AccelerometerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccelerometerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccelerometerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccelerometerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccelerometerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccelerometerValidationError) ErrorName() string { return "AccelerometerValidationError" }

// Error satisfies the builtin error interface
func (e AccelerometerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccelerometer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccelerometerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccelerometerValidationError{}

// Validate checks the field values on Magnetometer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Magnetometer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Magnetometer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MagnetometerMultiError, or
// nil if none found.
func (m *Magnetometer) ValidateAll() error {
	return m.validate(true)
}

func (m *Magnetometer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for X

	// no validation rules for Y

	// no validation rules for Z

	if len(errors) > 0 {
		return MagnetometerMultiError(errors)
	}

	return nil
}

// MagnetometerMultiError is an error wrapping multiple validation errors
// returned by Magnetometer.ValidateAll() if the designated constraints aren't met.
type MagnetometerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MagnetometerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MagnetometerMultiError) AllErrors() []error { return m }

// MagnetometerValidationError is the validation error returned by
// Magnetometer.Validate if the designated constraints aren't met.
type MagnetometerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MagnetometerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MagnetometerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MagnetometerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MagnetometerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MagnetometerValidationError) ErrorName() string { return "MagnetometerValidationError" }

// Error satisfies the builtin error interface
func (e MagnetometerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMagnetometer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MagnetometerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MagnetometerValidationError{}

// Validate checks the field values on Gyroscope with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Gyroscope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Gyroscope with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GyroscopeMultiError, or nil
// if none found.
func (m *Gyroscope) ValidateAll() error {
	return m.validate(true)
}

func (m *Gyroscope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for X

	// no validation rules for Y

	// no validation rules for Z

	if len(errors) > 0 {
		return GyroscopeMultiError(errors)
	}

	return nil
}

// GyroscopeMultiError is an error wrapping multiple validation errors returned
// by Gyroscope.ValidateAll() if the designated constraints aren't met.
type GyroscopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GyroscopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GyroscopeMultiError) AllErrors() []error { return m }

// GyroscopeValidationError is the validation error returned by
// Gyroscope.Validate if the designated constraints aren't met.
type GyroscopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GyroscopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GyroscopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GyroscopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GyroscopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GyroscopeValidationError) ErrorName() string { return "GyroscopeValidationError" }

// Error satisfies the builtin error interface
func (e GyroscopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGyroscope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GyroscopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GyroscopeValidationError{}

// Validate checks the field values on Pointer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pointer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pointer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PointerMultiError, or nil if none found.
func (m *Pointer) ValidateAll() error {
	return m.validate(true)
}

func (m *Pointer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for Type

	// no validation rules for Buttons

	if all {
		switch v := interface{}(m.GetDelta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Delta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Delta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "Delta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Device

	// no validation rules for Distance

	if all {
		switch v := interface{}(m.GetDistanceRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "DistanceRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "DistanceRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDistanceRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "DistanceRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Obscured

	// no validation rules for Orientation

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Pressure

	if all {
		switch v := interface{}(m.GetPressureRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "PressureRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "PressureRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPressureRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "PressureRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RadiusMajor

	// no validation rules for RadiusMinor

	if all {
		switch v := interface{}(m.GetRadiusRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "RadiusRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "RadiusRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRadiusRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "RadiusRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Size

	// no validation rules for Synthesized

	// no validation rules for Tilt

	// no validation rules for IsSoftwareKeyboard

	// no validation rules for ViewportBoundaryStatus

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointerValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointerValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PointerMultiError(errors)
	}

	return nil
}

// PointerMultiError is an error wrapping multiple validation errors returned
// by Pointer.ValidateAll() if the designated constraints aren't met.
type PointerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PointerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PointerMultiError) AllErrors() []error { return m }

// PointerValidationError is the validation error returned by Pointer.Validate
// if the designated constraints aren't met.
type PointerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PointerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PointerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PointerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PointerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PointerValidationError) ErrorName() string { return "PointerValidationError" }

// Error satisfies the builtin error interface
func (e PointerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPointer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PointerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PointerValidationError{}

// Validate checks the field values on Click with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Click) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Click with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClickMultiError, or nil if none found.
func (m *Click) ValidateAll() error {
	return m.validate(true)
}

func (m *Click) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClickValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClickValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClickValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClickValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClickValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClickValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClickMultiError(errors)
	}

	return nil
}

// ClickMultiError is an error wrapping multiple validation errors returned by
// Click.ValidateAll() if the designated constraints aren't met.
type ClickMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClickMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClickMultiError) AllErrors() []error { return m }

// ClickValidationError is the validation error returned by Click.Validate if
// the designated constraints aren't met.
type ClickValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClickValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClickValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClickValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClickValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClickValidationError) ErrorName() string { return "ClickValidationError" }

// Error satisfies the builtin error interface
func (e ClickValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClick.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClickValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClickValidationError{}

// Validate checks the field values on TargetElement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TargetElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TargetElement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TargetElementMultiError, or
// nil if none found.
func (m *TargetElement) ValidateAll() error {
	return m.validate(true)
}

func (m *TargetElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetId

	// no validation rules for TargetType

	if len(errors) > 0 {
		return TargetElementMultiError(errors)
	}

	return nil
}

// TargetElementMultiError is an error wrapping multiple validation errors
// returned by TargetElement.ValidateAll() if the designated constraints
// aren't met.
type TargetElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetElementMultiError) AllErrors() []error { return m }

// TargetElementValidationError is the validation error returned by
// TargetElement.Validate if the designated constraints aren't met.
type TargetElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetElementValidationError) ErrorName() string { return "TargetElementValidationError" }

// Error satisfies the builtin error interface
func (e TargetElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTargetElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetElementValidationError{}

// Validate checks the field values on TextChange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TextChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TextChange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TextChangeMultiError, or
// nil if none found.
func (m *TextChange) ValidateAll() error {
	return m.validate(true)
}

func (m *TextChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TextChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TextChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TextChangeValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Focus

	// no validation rules for MaskedText

	// no validation rules for TruncatedText

	// no validation rules for Action

	if len(errors) > 0 {
		return TextChangeMultiError(errors)
	}

	return nil
}

// TextChangeMultiError is an error wrapping multiple validation errors
// returned by TextChange.ValidateAll() if the designated constraints aren't met.
type TextChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TextChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TextChangeMultiError) AllErrors() []error { return m }

// TextChangeValidationError is the validation error returned by
// TextChange.Validate if the designated constraints aren't met.
type TextChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TextChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TextChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TextChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TextChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TextChangeValidationError) ErrorName() string { return "TextChangeValidationError" }

// Error satisfies the builtin error interface
func (e TextChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTextChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TextChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TextChangeValidationError{}

// Validate checks the field values on InputChange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InputChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InputChange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InputChangeMultiError, or
// nil if none found.
func (m *InputChange) ValidateAll() error {
	return m.validate(true)
}

func (m *InputChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InputChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InputChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InputChangeValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Focus

	// no validation rules for MaskedText

	// no validation rules for TruncatedText

	// no validation rules for Action

	if len(errors) > 0 {
		return InputChangeMultiError(errors)
	}

	return nil
}

// InputChangeMultiError is an error wrapping multiple validation errors
// returned by InputChange.ValidateAll() if the designated constraints aren't met.
type InputChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InputChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InputChangeMultiError) AllErrors() []error { return m }

// InputChangeValidationError is the validation error returned by
// InputChange.Validate if the designated constraints aren't met.
type InputChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InputChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InputChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InputChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InputChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InputChangeValidationError) ErrorName() string { return "InputChangeValidationError" }

// Error satisfies the builtin error interface
func (e InputChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInputChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InputChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InputChangeValidationError{}

// Validate checks the field values on KeyPress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyPress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyPress with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyPressMultiError, or nil
// if none found.
func (m *KeyPress) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyPress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for Type

	// no validation rules for SpecialKey

	// no validation rules for MaskedKey

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyPressValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyPressValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyPressValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AltKey

	// no validation rules for ControlKey

	// no validation rules for MetaKey

	// no validation rules for ShiftKey

	if len(errors) > 0 {
		return KeyPressMultiError(errors)
	}

	return nil
}

// KeyPressMultiError is an error wrapping multiple validation errors returned
// by KeyPress.ValidateAll() if the designated constraints aren't met.
type KeyPressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyPressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyPressMultiError) AllErrors() []error { return m }

// KeyPressValidationError is the validation error returned by
// KeyPress.Validate if the designated constraints aren't met.
type KeyPressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyPressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyPressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyPressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyPressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyPressValidationError) ErrorName() string { return "KeyPressValidationError" }

// Error satisfies the builtin error interface
func (e KeyPressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyPress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyPressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyPressValidationError{}

// Validate checks the field values on FocusChange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusChange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FocusChangeMultiError, or
// nil if none found.
func (m *FocusChange) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FocusChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FocusChangeValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FocusChangeValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FocusChangeMultiError(errors)
	}

	return nil
}

// FocusChangeMultiError is an error wrapping multiple validation errors
// returned by FocusChange.ValidateAll() if the designated constraints aren't met.
type FocusChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusChangeMultiError) AllErrors() []error { return m }

// FocusChangeValidationError is the validation error returned by
// FocusChange.Validate if the designated constraints aren't met.
type FocusChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusChangeValidationError) ErrorName() string { return "FocusChangeValidationError" }

// Error satisfies the builtin error interface
func (e FocusChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusChangeValidationError{}

// Validate checks the field values on ViewportScroll with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ViewportScroll) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ViewportScroll with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ViewportScrollMultiError,
// or nil if none found.
func (m *ViewportScroll) ValidateAll() error {
	return m.validate(true)
}

func (m *ViewportScroll) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for XPosition

	// no validation rules for YPosition

	if len(errors) > 0 {
		return ViewportScrollMultiError(errors)
	}

	return nil
}

// ViewportScrollMultiError is an error wrapping multiple validation errors
// returned by ViewportScroll.ValidateAll() if the designated constraints
// aren't met.
type ViewportScrollMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ViewportScrollMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ViewportScrollMultiError) AllErrors() []error { return m }

// ViewportScrollValidationError is the validation error returned by
// ViewportScroll.Validate if the designated constraints aren't met.
type ViewportScrollValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ViewportScrollValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ViewportScrollValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ViewportScrollValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ViewportScrollValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ViewportScrollValidationError) ErrorName() string { return "ViewportScrollValidationError" }

// Error satisfies the builtin error interface
func (e ViewportScrollValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sViewportScroll.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ViewportScrollValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ViewportScrollValidationError{}

// Validate checks the field values on MouseWheel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MouseWheel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MouseWheel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MouseWheelMultiError, or
// nil if none found.
func (m *MouseWheel) ValidateAll() error {
	return m.validate(true)
}

func (m *MouseWheel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for WheelDeltaX

	// no validation rules for WheelDeltaY

	// no validation rules for WheelMode

	// no validation rules for WheelDeltaXLine

	// no validation rules for WheelDeltaYLine

	// no validation rules for WheelDeltaXPage

	// no validation rules for WheelDeltaYPage

	if len(errors) > 0 {
		return MouseWheelMultiError(errors)
	}

	return nil
}

// MouseWheelMultiError is an error wrapping multiple validation errors
// returned by MouseWheel.ValidateAll() if the designated constraints aren't met.
type MouseWheelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MouseWheelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MouseWheelMultiError) AllErrors() []error { return m }

// MouseWheelValidationError is the validation error returned by
// MouseWheel.Validate if the designated constraints aren't met.
type MouseWheelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MouseWheelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MouseWheelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MouseWheelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MouseWheelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MouseWheelValidationError) ErrorName() string { return "MouseWheelValidationError" }

// Error satisfies the builtin error interface
func (e MouseWheelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMouseWheel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MouseWheelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MouseWheelValidationError{}

// Validate checks the field values on PermissionEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PermissionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PermissionEventMultiError, or nil if none found.
func (m *PermissionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for SensorType

	// no validation rules for PermissionStatus

	if len(errors) > 0 {
		return PermissionEventMultiError(errors)
	}

	return nil
}

// PermissionEventMultiError is an error wrapping multiple validation errors
// returned by PermissionEvent.ValidateAll() if the designated constraints
// aren't met.
type PermissionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionEventMultiError) AllErrors() []error { return m }

// PermissionEventValidationError is the validation error returned by
// PermissionEvent.Validate if the designated constraints aren't met.
type PermissionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionEventValidationError) ErrorName() string { return "PermissionEventValidationError" }

// Error satisfies the builtin error interface
func (e PermissionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionEventValidationError{}

// Validate checks the field values on ViewportSizeEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ViewportSizeEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ViewportSizeEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ViewportSizeEventMultiError, or nil if none found.
func (m *ViewportSizeEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ViewportSizeEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for DevicePhysicalWidth

	// no validation rules for DevicePhysicalHeight

	// no validation rules for DeviceLogicalWidth

	// no validation rules for DeviceLogicalHeight

	// no validation rules for DevicePixelRatio

	// no validation rules for ViewportOrientation

	if len(errors) > 0 {
		return ViewportSizeEventMultiError(errors)
	}

	return nil
}

// ViewportSizeEventMultiError is an error wrapping multiple validation errors
// returned by ViewportSizeEvent.ValidateAll() if the designated constraints
// aren't met.
type ViewportSizeEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ViewportSizeEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ViewportSizeEventMultiError) AllErrors() []error { return m }

// ViewportSizeEventValidationError is the validation error returned by
// ViewportSizeEvent.Validate if the designated constraints aren't met.
type ViewportSizeEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ViewportSizeEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ViewportSizeEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ViewportSizeEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ViewportSizeEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ViewportSizeEventValidationError) ErrorName() string {
	return "ViewportSizeEventValidationError"
}

// Error satisfies the builtin error interface
func (e ViewportSizeEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sViewportSizeEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ViewportSizeEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ViewportSizeEventValidationError{}

// Validate checks the field values on AppLifeCycleEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AppLifeCycleEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppLifeCycleEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppLifeCycleEventMultiError, or nil if none found.
func (m *AppLifeCycleEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AppLifeCycleEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for AppLifeCycleStatus

	if len(errors) > 0 {
		return AppLifeCycleEventMultiError(errors)
	}

	return nil
}

// AppLifeCycleEventMultiError is an error wrapping multiple validation errors
// returned by AppLifeCycleEvent.ValidateAll() if the designated constraints
// aren't met.
type AppLifeCycleEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppLifeCycleEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppLifeCycleEventMultiError) AllErrors() []error { return m }

// AppLifeCycleEventValidationError is the validation error returned by
// AppLifeCycleEvent.Validate if the designated constraints aren't met.
type AppLifeCycleEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppLifeCycleEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppLifeCycleEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppLifeCycleEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppLifeCycleEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppLifeCycleEventValidationError) ErrorName() string {
	return "AppLifeCycleEventValidationError"
}

// Error satisfies the builtin error interface
func (e AppLifeCycleEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppLifeCycleEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppLifeCycleEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppLifeCycleEventValidationError{}

// Validate checks the field values on CustomEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CustomEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomEventMultiError, or
// nil if none found.
func (m *CustomEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for EventName

	// no validation rules for Properties

	// no validation rules for EventKey

	if len(errors) > 0 {
		return CustomEventMultiError(errors)
	}

	return nil
}

// CustomEventMultiError is an error wrapping multiple validation errors
// returned by CustomEvent.ValidateAll() if the designated constraints aren't met.
type CustomEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomEventMultiError) AllErrors() []error { return m }

// CustomEventValidationError is the validation error returned by
// CustomEvent.Validate if the designated constraints aren't met.
type CustomEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomEventValidationError) ErrorName() string { return "CustomEventValidationError" }

// Error satisfies the builtin error interface
func (e CustomEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomEventValidationError{}

// Validate checks the field values on FormSubmitEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FormSubmitEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FormSubmitEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FormSubmitEventMultiError, or nil if none found.
func (m *FormSubmitEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *FormSubmitEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	if all {
		switch v := interface{}(m.GetSubmitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FormSubmitEventValidationError{
					field:  "Submitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FormSubmitEventValidationError{
					field:  "Submitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FormSubmitEventValidationError{
				field:  "Submitter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FormSubmitEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FormSubmitEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FormSubmitEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FormSubmitEventMultiError(errors)
	}

	return nil
}

// FormSubmitEventMultiError is an error wrapping multiple validation errors
// returned by FormSubmitEvent.ValidateAll() if the designated constraints
// aren't met.
type FormSubmitEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FormSubmitEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FormSubmitEventMultiError) AllErrors() []error { return m }

// FormSubmitEventValidationError is the validation error returned by
// FormSubmitEvent.Validate if the designated constraints aren't met.
type FormSubmitEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FormSubmitEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FormSubmitEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FormSubmitEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FormSubmitEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FormSubmitEventValidationError) ErrorName() string { return "FormSubmitEventValidationError" }

// Error satisfies the builtin error interface
func (e FormSubmitEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFormSubmitEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FormSubmitEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FormSubmitEventValidationError{}

// Validate checks the field values on ContextMenuEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContextMenuEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContextMenuEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContextMenuEventMultiError, or nil if none found.
func (m *ContextMenuEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ContextMenuEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for ContextMenuStatus

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContextMenuEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContextMenuEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContextMenuEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContextMenuEventMultiError(errors)
	}

	return nil
}

// ContextMenuEventMultiError is an error wrapping multiple validation errors
// returned by ContextMenuEvent.ValidateAll() if the designated constraints
// aren't met.
type ContextMenuEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContextMenuEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContextMenuEventMultiError) AllErrors() []error { return m }

// ContextMenuEventValidationError is the validation error returned by
// ContextMenuEvent.Validate if the designated constraints aren't met.
type ContextMenuEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContextMenuEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContextMenuEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContextMenuEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContextMenuEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContextMenuEventValidationError) ErrorName() string { return "ContextMenuEventValidationError" }

// Error satisfies the builtin error interface
func (e ContextMenuEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContextMenuEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContextMenuEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContextMenuEventValidationError{}

// Validate checks the field values on FrameRateEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FrameRateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrameRateEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FrameRateEventMultiError,
// or nil if none found.
func (m *FrameRateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *FrameRateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeterminedAt

	// no validation rules for FramesPerSecond

	if len(errors) > 0 {
		return FrameRateEventMultiError(errors)
	}

	return nil
}

// FrameRateEventMultiError is an error wrapping multiple validation errors
// returned by FrameRateEvent.ValidateAll() if the designated constraints
// aren't met.
type FrameRateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrameRateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrameRateEventMultiError) AllErrors() []error { return m }

// FrameRateEventValidationError is the validation error returned by
// FrameRateEvent.Validate if the designated constraints aren't met.
type FrameRateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrameRateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrameRateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrameRateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrameRateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrameRateEventValidationError) ErrorName() string { return "FrameRateEventValidationError" }

// Error satisfies the builtin error interface
func (e FrameRateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrameRateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrameRateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrameRateEventValidationError{}
